{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nconst HighlightText = {\n  // 高亮选中的文字（支持跨节点）\n  highlightSelection() {\n    let highlightColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'yellow';\n    const selection = window.getSelection();\n    if (!selection.isCollapsed) {\n      const range = selection.getRangeAt(0);\n      const startContainer = range.startContainer;\n      const endContainer = range.endContainer;\n\n      // 如果选中的开始和结束是同一个文本节点\n      if (startContainer === endContainer && startContainer.nodeType === Node.TEXT_NODE) {\n        this.highlightSingleNodeText(range, startContainer, highlightColor);\n      } else {\n        // 否则处理跨多个节点的选区\n        this.highlightMultiNodeText(range, highlightColor);\n      }\n      selection.removeAllRanges(); // 清除选区\n    }\n  },\n  // 高亮单一文本节点的选区\n  highlightSingleNodeText(range, textNode, highlightColor) {\n    const startOffset = range.startOffset;\n    const endOffset = range.endOffset;\n\n    // 确保起始和结束偏移量在合法范围内\n    const validStartOffset = Math.min(startOffset, textNode.length);\n    const validEndOffset = Math.min(endOffset, textNode.length);\n    if (validStartOffset !== validEndOffset) {\n      // 分割文本节点，确保正确处理偏移\n      const highlightedText = textNode.splitText(validStartOffset); // 从起始偏移位置切分文本节点\n      highlightedText.splitText(validEndOffset - validStartOffset); // 从结束偏移位置切分文本节点\n\n      // 创建一个 span 来包裹选中的文本并应用高亮\n      const span = document.createElement('span');\n      span.style.backgroundColor = highlightColor; // 设置高亮样式\n      const parent = textNode.parentNode;\n\n      // 确保父节点不为 null，避免替换操作错误\n      if (parent) {\n        parent.replaceChild(span, textNode); // 替换原来的文本节点\n        span.appendChild(textNode); // 把切分后的文本节点添加到 span 中\n      }\n    }\n  },\n  // 高亮跨多个节点的选区\n  highlightMultiNodeText(range, highlightColor) {\n    const startContainer = range.startContainer;\n    const endContainer = range.endContainer;\n    let node = startContainer;\n    const nodesToHighlight = [];\n\n    // 确保正确遍历选区范围内的所有文本节点\n    while (node) {\n      if (node.nodeType === Node.TEXT_NODE) {\n        if (node === startContainer) {\n          // 如果是开始容器，截取从起始偏移到文本末尾\n          const span = document.createElement('span');\n          span.style.backgroundColor = highlightColor;\n          node.splitText(range.startOffset); // 仅处理开始偏移以后的部分\n          span.appendChild(node);\n          nodesToHighlight.push(span);\n        } else if (node === endContainer) {\n          // 如果是结束容器，截取从文本开始到结束偏移\n          const span = document.createElement('span');\n          span.style.backgroundColor = highlightColor;\n          node.splitText(range.endOffset); // 仅处理结束偏移前的部分\n          span.appendChild(node);\n          nodesToHighlight.push(span);\n        } else {\n          // 普通文本节点，直接添加到高亮列表\n          const span = document.createElement('span');\n          span.style.backgroundColor = highlightColor;\n          span.appendChild(node);\n          nodesToHighlight.push(span);\n        }\n      }\n\n      // 如果已遍历到结束容器，停止\n      if (node === endContainer) break;\n      node = this.getNextNode(node);\n    }\n\n    // 在父节点中替换原有文本节点为高亮节点\n    nodesToHighlight.forEach(highlightedNode => {\n      const parent = highlightedNode.firstChild ? highlightedNode.firstChild.parentNode : null;\n      if (parent && !parent.contains(highlightedNode)) {\n        parent.replaceChild(highlightedNode, parent.firstChild); // 替换原有节点\n      }\n    });\n  },\n  // 获取下一个节点\n  getNextNode(node) {\n    if (node.firstChild) return node.firstChild;\n    while (node) {\n      if (node.nextSibling) return node.nextSibling;\n      node = node.parentNode;\n    }\n    return null;\n  }\n};\nexport default HighlightText;","map":{"version":3,"names":["HighlightText","highlightSelection","highlightColor","arguments","length","undefined","selection","window","getSelection","isCollapsed","range","getRangeAt","startContainer","endContainer","nodeType","Node","TEXT_NODE","highlightSingleNodeText","highlightMultiNodeText","removeAllRanges","textNode","startOffset","endOffset","validStartOffset","Math","min","validEndOffset","highlightedText","splitText","span","document","createElement","style","backgroundColor","parent","parentNode","replaceChild","appendChild","node","nodesToHighlight","push","getNextNode","forEach","highlightedNode","firstChild","contains","nextSibling"],"sources":["D:/vue_frame/vue_frame/wikitable-vue/client/src/js/highlight.js"],"sourcesContent":["const HighlightText = {\r\n  // 高亮选中的文字（支持跨节点）\r\n  highlightSelection(highlightColor = 'yellow') {\r\n    const selection = window.getSelection();\r\n    if (!selection.isCollapsed) {\r\n      const range = selection.getRangeAt(0);\r\n      const startContainer = range.startContainer;\r\n      const endContainer = range.endContainer;\r\n\r\n      // 如果选中的开始和结束是同一个文本节点\r\n      if (startContainer === endContainer && startContainer.nodeType === Node.TEXT_NODE) {\r\n        this.highlightSingleNodeText(range, startContainer, highlightColor);\r\n      } else {\r\n        // 否则处理跨多个节点的选区\r\n        this.highlightMultiNodeText(range, highlightColor);\r\n      }\r\n\r\n      selection.removeAllRanges(); // 清除选区\r\n    }\r\n  },\r\n\r\n  // 高亮单一文本节点的选区\r\n  highlightSingleNodeText(range, textNode, highlightColor) {\r\n    const startOffset = range.startOffset;\r\n    const endOffset = range.endOffset;\r\n\r\n    // 确保起始和结束偏移量在合法范围内\r\n    const validStartOffset = Math.min(startOffset, textNode.length);\r\n    const validEndOffset = Math.min(endOffset, textNode.length);\r\n\r\n    if (validStartOffset !== validEndOffset) {\r\n      // 分割文本节点，确保正确处理偏移\r\n      const highlightedText = textNode.splitText(validStartOffset); // 从起始偏移位置切分文本节点\r\n      highlightedText.splitText(validEndOffset - validStartOffset); // 从结束偏移位置切分文本节点\r\n\r\n      // 创建一个 span 来包裹选中的文本并应用高亮\r\n      const span = document.createElement('span');\r\n      span.style.backgroundColor = highlightColor; // 设置高亮样式\r\n      const parent = textNode.parentNode;\r\n\r\n      // 确保父节点不为 null，避免替换操作错误\r\n      if (parent) {\r\n        parent.replaceChild(span, textNode); // 替换原来的文本节点\r\n        span.appendChild(textNode); // 把切分后的文本节点添加到 span 中\r\n      }\r\n    }\r\n  },\r\n\r\n  // 高亮跨多个节点的选区\r\n  highlightMultiNodeText(range, highlightColor) {\r\n    const startContainer = range.startContainer;\r\n    const endContainer = range.endContainer;\r\n\r\n    let node = startContainer;\r\n    const nodesToHighlight = [];\r\n\r\n    // 确保正确遍历选区范围内的所有文本节点\r\n    while (node) {\r\n      if (node.nodeType === Node.TEXT_NODE) {\r\n        if (node === startContainer) {\r\n          // 如果是开始容器，截取从起始偏移到文本末尾\r\n          const span = document.createElement('span');\r\n          span.style.backgroundColor = highlightColor;\r\n          node.splitText(range.startOffset); // 仅处理开始偏移以后的部分\r\n          span.appendChild(node);\r\n          nodesToHighlight.push(span);\r\n        } else if (node === endContainer) {\r\n          // 如果是结束容器，截取从文本开始到结束偏移\r\n          const span = document.createElement('span');\r\n          span.style.backgroundColor = highlightColor;\r\n          node.splitText(range.endOffset); // 仅处理结束偏移前的部分\r\n          span.appendChild(node);\r\n          nodesToHighlight.push(span);\r\n        } else {\r\n          // 普通文本节点，直接添加到高亮列表\r\n          const span = document.createElement('span');\r\n          span.style.backgroundColor = highlightColor;\r\n          span.appendChild(node);\r\n          nodesToHighlight.push(span);\r\n        }\r\n      }\r\n\r\n      // 如果已遍历到结束容器，停止\r\n      if (node === endContainer) break;\r\n\r\n      node = this.getNextNode(node);\r\n    }\r\n\r\n    // 在父节点中替换原有文本节点为高亮节点\r\n    nodesToHighlight.forEach((highlightedNode) => {\r\n      const parent = highlightedNode.firstChild ? highlightedNode.firstChild.parentNode : null;\r\n      if (parent && !parent.contains(highlightedNode)) {\r\n        parent.replaceChild(highlightedNode, parent.firstChild); // 替换原有节点\r\n      }\r\n    });\r\n  },\r\n\r\n  // 获取下一个节点\r\n  getNextNode(node) {\r\n    if (node.firstChild) return node.firstChild;\r\n    while (node) {\r\n      if (node.nextSibling) return node.nextSibling;\r\n      node = node.parentNode;\r\n    }\r\n    return null;\r\n  }\r\n};\r\n\r\nexport default HighlightText;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}