{"ast":null,"code":"const HighlightText = {\n  // 高亮选中的文字（支持跨节点）\n  highlightSelection() {\n    let highlightColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'yellow';\n    const selection = window.getSelection();\n    if (!selection.isCollapsed) {\n      const range = selection.getRangeAt(0);\n      const startContainer = range.startContainer;\n      const endContainer = range.endContainer;\n\n      // 如果选中的开始和结束是同一个文本节点\n      if (startContainer === endContainer && startContainer.nodeType === Node.TEXT_NODE) {\n        this.highlightSingleNodeText(range, startContainer, highlightColor);\n      } else {\n        // 否则处理跨多个节点的选区\n        this.highlightMultiNodeText(range, highlightColor);\n      }\n      selection.removeAllRanges(); // 清除选区\n    }\n  },\n  // 高亮单一文本节点的选区\n  highlightSingleNodeText(range, textNode, highlightColor) {\n    const startOffset = range.startOffset;\n    const endOffset = range.endOffset;\n\n    // 确保起始和结束偏移量在合法范围内\n    const validStartOffset = Math.min(startOffset, textNode.length);\n    const validEndOffset = Math.min(endOffset, textNode.length);\n\n    // 分割文本节点\n    const highlightedText = textNode.splitText(validStartOffset); // 从起始偏移位置切分文本节点\n    highlightedText.splitText(validEndOffset - validStartOffset); // 从结束偏移位置切分文本节点\n\n    // 创建一个 span 来包裹选中的文本并应用高亮\n    const span = document.createElement('span');\n    span.style.backgroundColor = highlightColor; // 设置高亮样式\n    const parent = textNode.parentNode;\n    parent.replaceChild(span, textNode); // 替换原来的文本节点\n    span.appendChild(textNode); // 把切分后的文本节点添加到 span 中\n  },\n  // 高亮跨多个节点的选区\n  highlightMultiNodeText(range, highlightColor) {\n    const startContainer = range.startContainer;\n    const endContainer = range.endContainer;\n    const highlightSpan = document.createElement('span');\n    highlightSpan.style.backgroundColor = highlightColor;\n    const fullRange = document.createRange();\n    fullRange.setStart(startContainer, range.startOffset);\n    fullRange.setEnd(endContainer, range.endOffset);\n\n    // 对选区中的所有文本节点应用高亮\n    fullRange.surroundContents(highlightSpan); // 用 span 包裹整个选区\n  },\n  // 获取下一个节点\n  getNextNode(node) {\n    if (node.firstChild) return node.firstChild;\n    while (node) {\n      if (node.nextSibling) return node.nextSibling;\n      node = node.parentNode;\n    }\n    return null;\n  }\n};\nexport default HighlightText;","map":{"version":3,"names":["HighlightText","highlightSelection","highlightColor","arguments","length","undefined","selection","window","getSelection","isCollapsed","range","getRangeAt","startContainer","endContainer","nodeType","Node","TEXT_NODE","highlightSingleNodeText","highlightMultiNodeText","removeAllRanges","textNode","startOffset","endOffset","validStartOffset","Math","min","validEndOffset","highlightedText","splitText","span","document","createElement","style","backgroundColor","parent","parentNode","replaceChild","appendChild","highlightSpan","fullRange","createRange","setStart","setEnd","surroundContents","getNextNode","node","firstChild","nextSibling"],"sources":["D:/vue_frame/vue_frame/wikitable-vue/client/src/js/highlight.js"],"sourcesContent":["const HighlightText = {\r\n  // 高亮选中的文字（支持跨节点）\r\n  highlightSelection(highlightColor = 'yellow') {\r\n    const selection = window.getSelection();\r\n    if (!selection.isCollapsed) {\r\n      const range = selection.getRangeAt(0);\r\n      const startContainer = range.startContainer;\r\n      const endContainer = range.endContainer;\r\n\r\n      // 如果选中的开始和结束是同一个文本节点\r\n      if (startContainer === endContainer && startContainer.nodeType === Node.TEXT_NODE) {\r\n        this.highlightSingleNodeText(range, startContainer, highlightColor);\r\n      } else {\r\n        // 否则处理跨多个节点的选区\r\n        this.highlightMultiNodeText(range, highlightColor);\r\n      }\r\n\r\n      selection.removeAllRanges(); // 清除选区\r\n    }\r\n  },\r\n\r\n  // 高亮单一文本节点的选区\r\n  highlightSingleNodeText(range, textNode, highlightColor) {\r\n    const startOffset = range.startOffset;\r\n    const endOffset = range.endOffset;\r\n\r\n    // 确保起始和结束偏移量在合法范围内\r\n    const validStartOffset = Math.min(startOffset, textNode.length);\r\n    const validEndOffset = Math.min(endOffset, textNode.length);\r\n\r\n    // 分割文本节点\r\n    const highlightedText = textNode.splitText(validStartOffset); // 从起始偏移位置切分文本节点\r\n    highlightedText.splitText(validEndOffset - validStartOffset); // 从结束偏移位置切分文本节点\r\n\r\n    // 创建一个 span 来包裹选中的文本并应用高亮\r\n    const span = document.createElement('span');\r\n    span.style.backgroundColor = highlightColor; // 设置高亮样式\r\n    const parent = textNode.parentNode;\r\n    parent.replaceChild(span, textNode); // 替换原来的文本节点\r\n    span.appendChild(textNode); // 把切分后的文本节点添加到 span 中\r\n  },\r\n\r\n  // 高亮跨多个节点的选区\r\n  highlightMultiNodeText(range, highlightColor) {\r\n    const startContainer = range.startContainer;\r\n    const endContainer = range.endContainer;\r\n\r\n    const highlightSpan = document.createElement('span');\r\n    highlightSpan.style.backgroundColor = highlightColor;\r\n\r\n    const fullRange = document.createRange();\r\n    fullRange.setStart(startContainer, range.startOffset);\r\n    fullRange.setEnd(endContainer, range.endOffset);\r\n\r\n    // 对选区中的所有文本节点应用高亮\r\n    fullRange.surroundContents(highlightSpan); // 用 span 包裹整个选区\r\n  },\r\n\r\n  // 获取下一个节点\r\n  getNextNode(node) {\r\n    if (node.firstChild) return node.firstChild;\r\n    while (node) {\r\n      if (node.nextSibling) return node.nextSibling;\r\n      node = node.parentNode;\r\n    }\r\n    return null;\r\n  }\r\n};\r\n\r\nexport default HighlightText;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}