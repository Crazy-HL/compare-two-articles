{"ast":null,"code":"import { createCommentVNode as _createCommentVNode, toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, Fragment as _Fragment, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\nconst _withScopeId = n => (_pushScopeId(\"data-v-a89cbc96\"), n = n(), _popScopeId(), n);\nconst _hoisted_1 = {\n  class: \"simple-chart\"\n};\nconst _hoisted_2 = {\n  key: 0,\n  class: \"text-tooltip\"\n};\nconst _hoisted_3 = {\n  key: 0,\n  class: \"d3-chart-container\",\n  ref: \"pieContainer\"\n};\nconst _hoisted_4 = {\n  key: 1,\n  class: \"no-data\"\n};\nconst _hoisted_5 = {\n  key: 0,\n  class: \"d3-chart-container\",\n  ref: \"barContainer\"\n};\nconst _hoisted_6 = {\n  key: 1,\n  class: \"no-data\"\n};\nconst _hoisted_7 = {\n  key: 0,\n  class: \"d3-chart-container\",\n  ref: \"lineContainer\"\n};\nconst _hoisted_8 = {\n  key: 1,\n  class: \"no-data\"\n};\nconst _hoisted_9 = {\n  key: 0,\n  class: \"d3-chart-container\",\n  ref: \"stackedContainer\"\n};\nconst _hoisted_10 = {\n  key: 1,\n  class: \"no-data\"\n};\nconst _hoisted_11 = {\n  class: \"simple-text\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_createCommentVNode(\" 文本显示 \"), $props.visualization === 'text-only' ? (_openBlock(), _createElementBlock(_Fragment, {\n    key: 0\n  }, [_createElementVNode(\"div\", {\n    class: \"simple-text\",\n    onClick: _cache[0] || (_cache[0] = function () {\n      return $setup.handleTextClick && $setup.handleTextClick(...arguments);\n    }),\n    onMouseenter: _cache[1] || (_cache[1] = function () {\n      return $setup.handleTextHover && $setup.handleTextHover(...arguments);\n    }),\n    onMouseleave: _cache[2] || (_cache[2] = function () {\n      return $setup.resetHover && $setup.resetHover(...arguments);\n    })\n  }, _toDisplayString($setup.formatSimpleText(_ctx.processedField)), 33 /* TEXT, NEED_HYDRATION */), $setup.isTextHovered ? (_openBlock(), _createElementBlock(\"div\", _hoisted_2, \"点击查看详情\")) : _createCommentVNode(\"v-if\", true)], 64 /* STABLE_FRAGMENT */)) : $props.visualization === 'pie-chart' ? (_openBlock(), _createElementBlock(_Fragment, {\n    key: 1\n  }, [_createCommentVNode(\" 饼图 (D3实现) \"), $setup.hasData && $setup.isValidPieData ? (_openBlock(), _createElementBlock(\"div\", _hoisted_3, null, 512 /* NEED_PATCH */)) : (_openBlock(), _createElementBlock(\"div\", _hoisted_4, \"-\"))], 64 /* STABLE_FRAGMENT */)) : $props.visualization === 'bar-chart' ? (_openBlock(), _createElementBlock(_Fragment, {\n    key: 2\n  }, [_createCommentVNode(\" 柱状图 (D3实现) \"), $setup.hasData ? (_openBlock(), _createElementBlock(\"div\", _hoisted_5, null, 512 /* NEED_PATCH */)) : (_openBlock(), _createElementBlock(\"div\", _hoisted_6, \"-\"))], 64 /* STABLE_FRAGMENT */)) : $props.visualization === 'line-chart' ? (_openBlock(), _createElementBlock(_Fragment, {\n    key: 3\n  }, [_createCommentVNode(\" 折线图 (D3实现) \"), $setup.hasData ? (_openBlock(), _createElementBlock(\"div\", _hoisted_7, null, 512 /* NEED_PATCH */)) : (_openBlock(), _createElementBlock(\"div\", _hoisted_8, \"-\"))], 64 /* STABLE_FRAGMENT */)) : $props.visualization === 'stacked-chart' ? (_openBlock(), _createElementBlock(_Fragment, {\n    key: 4\n  }, [_createCommentVNode(\" 堆叠图 (100%纵向堆叠) \"), $setup.hasData ? (_openBlock(), _createElementBlock(\"div\", _hoisted_9, null, 512 /* NEED_PATCH */)) : (_openBlock(), _createElementBlock(\"div\", _hoisted_10, \"-\"))], 64 /* STABLE_FRAGMENT */)) : (_openBlock(), _createElementBlock(_Fragment, {\n    key: 5\n  }, [_createCommentVNode(\" 默认显示 (理论上所有类型都应被上面覆盖) \"), _createElementVNode(\"div\", _hoisted_11, \"未知图表类型: \" + _toDisplayString($props.visualization), 1 /* TEXT */)], 64 /* STABLE_FRAGMENT */))]);\n}","map":{"version":3,"names":["class","key","ref","_createElementBlock","_hoisted_1","_createCommentVNode","$props","visualization","_Fragment","_createElementVNode","onClick","_cache","$setup","handleTextClick","arguments","onMouseenter","handleTextHover","onMouseleave","resetHover","formatSimpleText","_ctx","processedField","isTextHovered","_hoisted_2","hasData","isValidPieData","_hoisted_3","_hoisted_4","_hoisted_5","_hoisted_6","_hoisted_7","_hoisted_8","_hoisted_9","_hoisted_10","_hoisted_11","_toDisplayString"],"sources":["D:\\vue_frame\\vue_frame\\wikitable-vue\\client\\src\\components\\compoents_base\\SimpleChart.vue"],"sourcesContent":["<template>\r\n\t<div class=\"simple-chart\">\r\n\t\t<!-- 文本显示 -->\r\n\t\t<template v-if=\"visualization === 'text-only'\">\r\n\t\t\t<div\r\n\t\t\t\tclass=\"simple-text\"\r\n\t\t\t\t@click=\"handleTextClick\"\r\n\t\t\t\t@mouseenter=\"handleTextHover\"\r\n\t\t\t\t@mouseleave=\"resetHover\">\r\n\t\t\t\t{{ formatSimpleText(processedField) }}\r\n\t\t\t</div>\r\n\t\t\t<div v-if=\"isTextHovered\" class=\"text-tooltip\">点击查看详情</div>\r\n\t\t</template>\r\n\r\n\t\t<!-- 饼图 (D3实现) -->\r\n\t\t<template v-else-if=\"visualization === 'pie-chart'\">\r\n\t\t\t<div\r\n\t\t\t\tv-if=\"hasData && isValidPieData\"\r\n\t\t\t\tclass=\"d3-chart-container\"\r\n\t\t\t\tref=\"pieContainer\"></div>\r\n\t\t\t<div v-else class=\"no-data\">-</div>\r\n\t\t</template>\r\n\r\n\t\t<!-- 柱状图 (D3实现) -->\r\n\t\t<template v-else-if=\"visualization === 'bar-chart'\">\r\n\t\t\t<div v-if=\"hasData\" class=\"d3-chart-container\" ref=\"barContainer\"></div>\r\n\t\t\t<div v-else class=\"no-data\">-</div>\r\n\t\t</template>\r\n\r\n\t\t<!-- 折线图 (D3实现) -->\r\n\t\t<template v-else-if=\"visualization === 'line-chart'\">\r\n\t\t\t<div v-if=\"hasData\" class=\"d3-chart-container\" ref=\"lineContainer\"></div>\r\n\t\t\t<div v-else class=\"no-data\">-</div>\r\n\t\t</template>\r\n\r\n\t\t<!-- 堆叠图 (100%纵向堆叠) -->\r\n\t\t<template v-else-if=\"visualization === 'stacked-chart'\">\r\n\t\t\t<div\r\n\t\t\t\tv-if=\"hasData\"\r\n\t\t\t\tclass=\"d3-chart-container\"\r\n\t\t\t\tref=\"stackedContainer\"></div>\r\n\t\t\t<div v-else class=\"no-data\">-</div>\r\n\t\t</template>\r\n\t\t<!-- 默认显示 (理论上所有类型都应被上面覆盖) -->\r\n\t\t<template v-else>\r\n\t\t\t<div class=\"simple-text\">未知图表类型: {{ visualization }}</div>\r\n\t\t</template>\r\n\t</div>\r\n</template>\r\n\r\n<script>\r\n\timport { computed, ref, onMounted, watch, nextTick } from \"vue\";\r\n\timport * as d3 from \"d3\";\r\n\r\n\texport default {\r\n\t\tprops: {\r\n\t\t\tfield: {\r\n\t\t\t\ttype: [Object, Array, String, Number],\r\n\t\t\t\tdefault: null\r\n\t\t\t},\r\n\t\t\ttype: {\r\n\t\t\t\t// e.g., \"percentage\", \"number\", \"text\"\r\n\t\t\t\ttype: String,\r\n\t\t\t\tdefault: \"\"\r\n\t\t\t},\r\n\t\t\tvisualization: {\r\n\t\t\t\t// e.g., \"pie-chart\", \"bar-chart\", \"text-only\"\r\n\t\t\t\ttype: String,\r\n\t\t\t\tdefault: \"\"\r\n\t\t\t},\r\n\t\t\tfieldKey: {\r\n\t\t\t\t// e.g., \"GDP\", \"Export goods\", \"GDP rank\"\r\n\t\t\t\ttype: String,\r\n\t\t\t\tdefault: \"\"\r\n\t\t\t},\r\n\t\t\tunifiedMax: {\r\n\t\t\t\ttype: Number,\r\n\t\t\t\tdefault: null\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\temits: [\"chartClick\"],\r\n\r\n\t\tsetup(props, { emit }) {\r\n\t\t\tconst hoveredIndex = ref(null); // Used by some chart interactions\r\n\t\t\tconst activeIndex = ref(null); // Used by some chart interactions\r\n\t\t\tconst isTextHovered = ref(false); // For text-only tooltip\r\n\r\n\t\t\t// DOM element references for D3\r\n\t\t\tconst pieContainer = ref(null);\r\n\t\t\tconst barContainer = ref(null);\r\n\t\t\tconst lineContainer = ref(null);\r\n\t\t\tconst stackedContainer = ref(null);\r\n\r\n\t\t\t// Color palette for charts\r\n\t\t\tconst colors = [\r\n\t\t\t\t\"#3498db\",\r\n\t\t\t\t\"#e74c3c\",\r\n\t\t\t\t\"#2ecc71\",\r\n\t\t\t\t\"#f39c12\",\r\n\t\t\t\t\"#9b59b6\",\r\n\t\t\t\t\"#1abc9c\",\r\n\t\t\t\t\"#d35400\",\r\n\t\t\t\t\"#8e44ad\",\r\n\t\t\t\t\"#c0392b\",\r\n\t\t\t\t\"#7f8c8d\"\r\n\t\t\t];\r\n\t\t\tconst remainderColor = \"#f0f0f0\"; // For single-value pie charts\r\n\r\n\t\t\t// Fixed data for 'stacked-chart' (Export goods for South Korea)\r\n\t\t\tconst fixedStackedChartRawData = [\r\n\t\t\t\t{ value: 15.35, raw: \"Integrated Circuits 15.35%\" },\r\n\t\t\t\t{ value: 12.81, raw: \"Machinery 12.81%\" },\r\n\t\t\t\t{ value: 11.34, raw: \"Vehicles and their parts 11.34%\" },\r\n\t\t\t\t{ value: 7.01, raw: \"Mineral Fuels 7.01%\" },\r\n\t\t\t\t{ value: 5.86, raw: \"Plastics 5.86%\" },\r\n\t\t\t\t{ value: 4.23, raw: \"Iron and Steel 4.23%\" },\r\n\t\t\t\t{ value: 4.16, raw: \"Instruments and Apparatus 4.16%\" },\r\n\t\t\t\t{ value: 3.85, raw: \"Organic Chemicals 3.85%\" },\r\n\t\t\t\t{ value: 35.39, raw: \"Others 35.39%\" }\r\n\t\t\t];\r\n\r\n\t\t\t// Helper to safely convert values to numbers for charts\r\n\t\t\tconst safeToNumber = value => {\r\n\t\t\t\tif (value === null || value === undefined) return 0;\r\n\t\t\t\tif (typeof value === \"number\" && !isNaN(value)) return value; // Ensure it's not NaN\r\n\t\t\t\tif (typeof value === \"string\") {\r\n\t\t\t\t\tconst cleanedString = value.replace(/[,亿万千]/g, \"\"); // Remove common non-numeric chars for parsing\r\n\t\t\t\t\tconst percentMatch = cleanedString.match(/(-?[\\d.]+)\\s*%/);\r\n\t\t\t\t\tif (percentMatch) return parseFloat(percentMatch[1]);\r\n\t\t\t\t\tconst num = parseFloat(cleanedString);\r\n\t\t\t\t\treturn isNaN(num) ? 0 : num;\r\n\t\t\t\t}\r\n\t\t\t\t// console.warn(\"safeToNumber could not parse:\", value, \"returning 0\");\r\n\t\t\t\treturn 0;\r\n\t\t\t};\r\n\r\n\t\t\t// Processes props.field into a consistent format for different chart types\r\n\t\t\tconst processedField = computed(() => {\r\n\t\t\t\t// console.log(`processedField: START for ${props.fieldKey} (${props.visualization}), props.field:`, JSON.parse(JSON.stringify(props.field)));\r\n\t\t\t\tif (props.visualization === \"stacked-chart\") {\r\n\t\t\t\t\tconst dataForStack = {};\r\n\t\t\t\t\tconst nameValueRegex =\r\n\t\t\t\t\t\t/^([a-zA-Z\\s&().]+[\\sa-zA-Z&().-]*?)\\s*([\\d.]+%)$/; // Allow hyphen in name\r\n\t\t\t\t\tfixedStackedChartRawData.forEach(item => {\r\n\t\t\t\t\t\tif (typeof item.raw !== \"string\") return;\r\n\t\t\t\t\t\tconst match = item.raw.match(nameValueRegex);\r\n\t\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\t\tconst name = match[1].trim();\r\n\t\t\t\t\t\t\tconst value = parseFloat(match[2]);\r\n\t\t\t\t\t\t\tif (!isNaN(value)) dataForStack[name] = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\t// console.log(`processedField: STACKED data prepared for D3 stack:`, dataForStack);\r\n\t\t\t\t\treturn Object.keys(dataForStack).length > 0 ? [dataForStack] : []; // Ensure it's an array, even if empty object led to empty keys\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (props.field === null || props.field === undefined) {\r\n\t\t\t\t\t// console.log(`processedField: props.field is null/undefined for ${props.fieldKey}`);\r\n\t\t\t\t\treturn props.visualization === \"text-only\" ? null : []; // text can be null, others expect array\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst processItem = itemInput => {\r\n\t\t\t\t\tif (typeof itemInput !== \"object\" || itemInput === null) {\r\n\t\t\t\t\t\t// Handle primitive values directly, especially for text-only or if data is simple\r\n\t\t\t\t\t\tconst rawText = String(itemInput);\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tname: rawText.split(/[:%（(]/)[0].trim() || \"Item\", // Basic name extraction\r\n\t\t\t\t\t\t\tvalue: props.type !== \"text\" ? safeToNumber(rawText) : rawText, // Convert to number unless it's text type\r\n\t\t\t\t\t\t\traw: rawText,\r\n\t\t\t\t\t\t\tunit: undefined,\r\n\t\t\t\t\t\t\ttype: props.type,\r\n\t\t\t\t\t\t\tyear: undefined,\r\n\t\t\t\t\t\t\tcurrency: undefined\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Item is an object\r\n\t\t\t\t\tconst name =\r\n\t\t\t\t\t\titemInput.name ||\r\n\t\t\t\t\t\t(typeof itemInput.raw === \"string\"\r\n\t\t\t\t\t\t\t? String(itemInput.raw)\r\n\t\t\t\t\t\t\t\t\t.split(/[:%（(]/)[0]\r\n\t\t\t\t\t\t\t\t\t.trim()\r\n\t\t\t\t\t\t\t: \"Item\");\r\n\t\t\t\t\tlet value;\r\n\t\t\t\t\tif (props.type === \"text\" || props.visualization === \"text-only\") {\r\n\t\t\t\t\t\tvalue =\r\n\t\t\t\t\t\t\titemInput.value !== undefined\r\n\t\t\t\t\t\t\t\t? String(itemInput.value)\r\n\t\t\t\t\t\t\t\t: String(itemInput.raw);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalue = safeToNumber(\r\n\t\t\t\t\t\t\titemInput.value !== undefined ? itemInput.value : itemInput.raw\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tname: name || \"Unknown\", // Ensure name exists\r\n\t\t\t\t\t\tvalue: value, // Value is processed\r\n\t\t\t\t\t\traw: String(\r\n\t\t\t\t\t\t\titemInput.raw ||\r\n\t\t\t\t\t\t\t\titemInput.value ||\r\n\t\t\t\t\t\t\t\tJSON.stringify(itemInput) ||\r\n\t\t\t\t\t\t\t\t\"\"\r\n\t\t\t\t\t\t), // Ensure raw is string\r\n\t\t\t\t\t\tunit: itemInput.unit,\r\n\t\t\t\t\t\ttype: itemInput.type || props.type, // Prefer item's type, fallback to prop\r\n\t\t\t\t\t\tyear: itemInput.year,\r\n\t\t\t\t\t\tcurrency: itemInput.currency\r\n\t\t\t\t\t};\r\n\t\t\t\t};\r\n\r\n\t\t\t\tlet result;\r\n\t\t\t\tif (Array.isArray(props.field)) {\r\n\t\t\t\t\tresult = props.field\r\n\t\t\t\t\t\t.map(processItem)\r\n\t\t\t\t\t\t.filter(item => item !== null && item.raw.trim() !== \"\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Single object or primitive\r\n\t\t\t\t\tresult = processItem(props.field);\r\n\t\t\t\t\t// For non-array results that aren't for text-only, wrap in array if it's an object\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tprops.visualization !== \"text-only\" &&\r\n\t\t\t\t\t\ttypeof result === \"object\" &&\r\n\t\t\t\t\t\tresult !== null\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tresult = [result];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// console.log(`processedField: END for ${props.fieldKey} (${props.visualization}), result:`, JSON.parse(JSON.stringify(result)));\r\n\t\t\t\treturn result;\r\n\t\t\t});\r\n\r\n\t\t\t// Determines if there's valid data to render a chart\r\n\t\t\tconst hasData = computed(() => {\r\n\t\t\t\tconst data = processedField.value;\r\n\t\t\t\t// console.log(`hasData check for ${props.fieldKey} (${props.visualization}): processedField.value =`, JSON.parse(JSON.stringify(data)));\r\n\t\t\t\tif (data === null || data === undefined) return false;\r\n\r\n\t\t\t\tif (props.visualization === \"stacked-chart\") {\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\tArray.isArray(data) &&\r\n\t\t\t\t\t\tdata.length === 1 &&\r\n\t\t\t\t\t\ttypeof data[0] === \"object\" &&\r\n\t\t\t\t\t\tObject.keys(data[0]).length > 0\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tif (Array.isArray(data)) {\r\n\t\t\t\t\treturn data.length > 0;\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof data === \"object\") {\r\n\t\t\t\t\t// Single object (can happen for text-only if props.field was an object)\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\tObject.keys(data).length > 0 &&\r\n\t\t\t\t\t\tdata.raw !== undefined &&\r\n\t\t\t\t\t\tString(data.raw).trim() !== \"\" &&\r\n\t\t\t\t\t\tString(data.raw).trim() !== \"-\"\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\t// Primitives for text-only\r\n\t\t\t\treturn String(data).trim().length > 0 && String(data).trim() !== \"-\";\r\n\t\t\t});\r\n\r\n\t\t\t// Specific validation for pie chart data\r\n\t\t\tconst isValidPieData = computed(() => {\r\n\t\t\t\tif (props.visualization !== \"pie-chart\" || !hasData.value) return false;\r\n\t\t\t\tconst data = processedField.value; // Already processed\r\n\t\t\t\tif (!Array.isArray(data) || data.length === 0) return false;\r\n\t\t\t\tconst valid = data.every(\r\n\t\t\t\t\titem =>\r\n\t\t\t\t\t\titem && // item exists\r\n\t\t\t\t\t\ttypeof item.name === \"string\" &&\r\n\t\t\t\t\t\ttypeof item.value === \"number\" &&\r\n\t\t\t\t\t\t!isNaN(item.value) && // value is a valid number\r\n\t\t\t\t\t\t!isYearEntry(item.name) &&\r\n\t\t\t\t\t\t!isYearEntry(item.raw) // Check raw for year entries too\r\n\t\t\t\t);\r\n\t\t\t\t// console.log(`isValidPieData for ${props.fieldKey}: ${valid}`, JSON.parse(JSON.stringify(data)));\r\n\t\t\t\treturn valid;\r\n\t\t\t});\r\n\r\n\t\t\tonMounted(() => {\r\n\t\t\t\t// console.log(`SimpleChart ONMOUNTED for fieldKey: ${props.fieldKey}, visualization: ${props.visualization}`);\r\n\t\t\t\twatch(\r\n\t\t\t\t\t() => [props.visualization, props.fieldKey, props.field, props.type], // Watch all relevant props\r\n\t\t\t\t\t() => {\r\n\t\t\t\t\t\t// console.log(`SimpleChart WATCH triggered - Vis: ${props.visualization}, Key: ${props.fieldKey}, Type: ${props.type}, HasData: ${hasData.value}`);\r\n\t\t\t\t\t\t// if (props.visualization === 'stacked-chart') {\r\n\t\t\t\t\t\t//      console.log(\"SimpleChart WATCH - Processed field for STACKED chart:\", JSON.parse(JSON.stringify(processedField.value)));\r\n\t\t\t\t\t\t// } else if (props.fieldKey === \"GDP rank\") {\r\n\t\t\t\t\t\t//      console.log(`SimpleChart WATCH - Processed field for GDP rank:`, JSON.parse(JSON.stringify(processedField.value)));\r\n\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\tnextTick(() => {\r\n\t\t\t\t\t\t\t// Clear previous chart before drawing new one\r\n\t\t\t\t\t\t\tif (pieContainer.value)\r\n\t\t\t\t\t\t\t\td3.select(pieContainer.value).selectAll(\"*\").remove();\r\n\t\t\t\t\t\t\tif (barContainer.value)\r\n\t\t\t\t\t\t\t\td3.select(barContainer.value).selectAll(\"*\").remove();\r\n\t\t\t\t\t\t\tif (lineContainer.value)\r\n\t\t\t\t\t\t\t\td3.select(lineContainer.value).selectAll(\"*\").remove();\r\n\t\t\t\t\t\t\tif (stackedContainer.value)\r\n\t\t\t\t\t\t\t\td3.select(stackedContainer.value).selectAll(\"*\").remove();\r\n\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tprops.visualization === \"pie-chart\" &&\r\n\t\t\t\t\t\t\t\thasData.value &&\r\n\t\t\t\t\t\t\t\tisValidPieData.value\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t// isValidPieData added\r\n\t\t\t\t\t\t\t\t// console.log(`SimpleChart: Conditions MET for renderPieChart (${props.fieldKey}).`);\r\n\t\t\t\t\t\t\t\trenderPieChart();\r\n\t\t\t\t\t\t\t} else if (props.visualization === \"bar-chart\" && hasData.value) {\r\n\t\t\t\t\t\t\t\t// console.log(`SimpleChart: Conditions MET for renderBarChart (${props.fieldKey}).`);\r\n\t\t\t\t\t\t\t\trenderBarChart();\r\n\t\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t\tprops.visualization === \"line-chart\" &&\r\n\t\t\t\t\t\t\t\thasData.value\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t// console.log(`SimpleChart: Conditions MET for renderLineChart (${props.fieldKey}).`);\r\n\t\t\t\t\t\t\t\trenderLineChart();\r\n\t\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\t\tprops.visualization === \"stacked-chart\" &&\r\n\t\t\t\t\t\t\t\thasData.value\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t// console.log(`SimpleChart: Conditions MET for renderStackedChart (${props.fieldKey}).`);\r\n\t\t\t\t\t\t\t\trenderStackedChart();\r\n\t\t\t\t\t\t\t} else if (props.visualization === \"text-only\") {\r\n\t\t\t\t\t\t\t\t// console.log(`SimpleChart: TEXT-ONLY display for ${props.fieldKey}. Data:`, JSON.parse(JSON.stringify(processedField.value)));\r\n\t\t\t\t\t\t\t\t// No explicit render function, template handles it\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// console.log(`SimpleChart: Conditions NOT MET for any specific chart. Vis: ${props.visualization}, Key: ${props.fieldKey}, HasData: ${hasData.value}, IsValidPie: ${props.visualization === 'pie-chart' ? isValidPieData.value : 'N/A'}`);\r\n\t\t\t\t\t\t\t\t// Optionally display a \"no data\" message in the container if it's not text-only\r\n\t\t\t\t\t\t\t\tconst containerRef =\r\n\t\t\t\t\t\t\t\t\tprops.visualization === \"pie-chart\"\r\n\t\t\t\t\t\t\t\t\t\t? pieContainer\r\n\t\t\t\t\t\t\t\t\t\t: props.visualization === \"bar-chart\"\r\n\t\t\t\t\t\t\t\t\t\t? barContainer\r\n\t\t\t\t\t\t\t\t\t\t: props.visualization === \"line-chart\"\r\n\t\t\t\t\t\t\t\t\t\t? lineContainer\r\n\t\t\t\t\t\t\t\t\t\t: props.visualization === \"stacked-chart\"\r\n\t\t\t\t\t\t\t\t\t\t? stackedContainer\r\n\t\t\t\t\t\t\t\t\t\t: null;\r\n\t\t\t\t\t\t\t\tif (containerRef && containerRef.value) {\r\n\t\t\t\t\t\t\t\t\td3.select(containerRef.value).html(\r\n\t\t\t\t\t\t\t\t\t\t`<div class=\"no-data\" style=\"text-align:center; width:100%;\">-</div>`\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{ immediate: true, deep: true }\r\n\t\t\t\t);\r\n\t\t\t});\r\n\r\n\t\t\tconst isYearEntry = value => {\r\n\t\t\t\t// Helper to filter out year-only entries\r\n\t\t\t\tif (typeof value !== \"string\") return false;\r\n\t\t\t\tconst trimmedValue = value.trim();\r\n\t\t\t\treturn (\r\n\t\t\t\t\t/^(\\(\\d{4}\\)|\\d{4}\\s*est\\.?)$/i.test(trimmedValue) ||\r\n\t\t\t\t\t/^\\(?[FY]+\\s*\\d{4}\\)?/i.test(trimmedValue)\r\n\t\t\t\t);\r\n\t\t\t};\r\n\r\n\t\t\t// Number formatting function\r\n\t\t\tconst formatNumber = value => {\r\n\t\t\t\t// console.log(`formatNumber called with value: \"${value}\", props.type: \"${props.type}\" for fieldKey: \"${props.fieldKey}\"`);\r\n\t\t\t\tif (value === undefined || value === null) {\r\n\t\t\t\t\t// console.warn(\"formatNumber received undefined or null value.\");\r\n\t\t\t\t\treturn \"-\";\r\n\t\t\t\t}\r\n\t\t\t\tconst num = Number(value); // Try to convert, handles strings like \"123.45\"\r\n\t\t\t\tif (isNaN(num)) {\r\n\t\t\t\t\t// console.warn(`formatNumber: Could not convert '${value}' to a valid number. Returning as is or \"-\" if not displayable.`);\r\n\t\t\t\t\t// For text that couldn't be converted, return the original string if it's not just noise\r\n\t\t\t\t\treturn typeof value === \"string\" &&\r\n\t\t\t\t\t\tvalue.trim() !== \"\" &&\r\n\t\t\t\t\t\tvalue.trim() !== \"-\"\r\n\t\t\t\t\t\t? value\r\n\t\t\t\t\t\t: \"-\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (props.type === \"percentage\") return num.toFixed(1) + \"%\";\r\n\t\t\t\tif (num >= 1e8) return (num / 1e8).toFixed(2) + \"亿\";\r\n\t\t\t\tif (num >= 1e4) return (num / 1e4).toFixed(1) + \"万\";\r\n\t\t\t\tif (Number.isInteger(num)) return num.toFixed(0); // No decimals for integers\r\n\t\t\t\treturn num.toFixed(1); // Default to 1 decimal for other numbers\r\n\t\t\t};\r\n\r\n\t\t\t// Pie chart data pre-processing\r\n\t\t\tconst pieData = computed(() => {\r\n\t\t\t\tif (\r\n\t\t\t\t\tprops.visualization !== \"pie-chart\" ||\r\n\t\t\t\t\t!hasData.value ||\r\n\t\t\t\t\t!Array.isArray(processedField.value)\r\n\t\t\t\t)\r\n\t\t\t\t\treturn [];\r\n\t\t\t\treturn processedField.value\r\n\t\t\t\t\t.map((item, index) => ({\r\n\t\t\t\t\t\tname: String(item.name || \"Unknown\"),\r\n\t\t\t\t\t\tvalue: typeof item.value === \"number\" ? item.value : 0, // Ensure value is number\r\n\t\t\t\t\t\traw: String(item.raw || \"\"),\r\n\t\t\t\t\t\tindex\r\n\t\t\t\t\t}))\r\n\t\t\t\t\t.filter(item => !isYearEntry(item.raw) && item.value > 0); // Filter out year entries and zero/negative values for pie\r\n\t\t\t});\r\n\r\n\t\t\tconst renderPieChart = () => {\r\n\t\t\t\tif (!pieContainer.value) {\r\n\t\t\t\t\t/* console.error(\"Pie container not found\"); */ return;\r\n\t\t\t\t}\r\n\t\t\t\t// console.log(`renderPieChart for ${props.fieldKey}, data:`, JSON.parse(JSON.stringify(pieData.value)));\r\n\t\t\t\td3.select(pieContainer.value).selectAll(\"*\").remove(); // Clear previous\r\n\t\t\t\tif (!pieData.value || pieData.value.length === 0) {\r\n\t\t\t\t\td3.select(pieContainer.value).html(`<div class=\"no-data\">-</div>`);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst container = d3.select(pieContainer.value);\r\n\t\t\t\tconst containerWidth = pieContainer.value.clientWidth;\r\n\t\t\t\tconst containerHeight = pieContainer.value.clientHeight;\r\n\t\t\t\tconst size = Math.min(containerWidth, containerHeight) * 0.95; // Slightly smaller\r\n\t\t\t\tconst radius = size / 2;\r\n\r\n\t\t\t\tconst svg = container\r\n\t\t\t\t\t.append(\"svg\")\r\n\t\t\t\t\t.attr(\"width\", \"100%\")\r\n\t\t\t\t\t.attr(\"height\", \"100%\")\r\n\t\t\t\t\t.attr(\"viewBox\", `0 0 ${size} ${size}`) // Centered viewport\r\n\t\t\t\t\t.append(\"g\")\r\n\t\t\t\t\t.attr(\"transform\", `translate(${radius},${radius})`);\r\n\r\n\t\t\t\tconst isSingleValue = props.fieldKey === \"Inflation (CPI)\"; // Or based on data length if only one item after filtering\r\n\t\t\t\tconst dataForPieDisplay =\r\n\t\t\t\t\tisSingleValue && pieData.value.length === 1\r\n\t\t\t\t\t\t? [\r\n\t\t\t\t\t\t\t\t{ ...pieData.value[0], color: colors[0] },\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tvalue: Math.max(0, 100 - pieData.value[0].value),\r\n\t\t\t\t\t\t\t\t\tname: \"剩余\",\r\n\t\t\t\t\t\t\t\t\tcolor: remainderColor,\r\n\t\t\t\t\t\t\t\t\tisRemainder: true\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t  ]\r\n\t\t\t\t\t\t: pieData.value.map((d, i) => ({\r\n\t\t\t\t\t\t\t\t...d,\r\n\t\t\t\t\t\t\t\tcolor: colors[i % colors.length]\r\n\t\t\t\t\t\t  }));\r\n\r\n\t\t\t\tconst pieGen = d3\r\n\t\t\t\t\t.pie()\r\n\t\t\t\t\t.value(d => d.value)\r\n\t\t\t\t\t.sort(null);\r\n\t\t\t\tconst arcGen = d3\r\n\t\t\t\t\t.arc()\r\n\t\t\t\t\t.innerRadius(isSingleValue ? radius * 0.7 : 0)\r\n\t\t\t\t\t.outerRadius(radius * 0.9)\r\n\t\t\t\t\t.cornerRadius(3); // Donut for single value\r\n\t\t\t\tconst tooltip = d3\r\n\t\t\t\t\t.select(pieContainer.value)\r\n\t\t\t\t\t.append(\"div\")\r\n\t\t\t\t\t.attr(\"class\", \"d3-tooltip\")\r\n\t\t\t\t\t.style(\"visibility\", \"hidden\");\r\n\r\n\t\t\t\tsvg\r\n\t\t\t\t\t.selectAll(\".arc-group\")\r\n\t\t\t\t\t.data(pieGen(dataForPieDisplay))\r\n\t\t\t\t\t.enter()\r\n\t\t\t\t\t.append(\"g\")\r\n\t\t\t\t\t.attr(\"class\", \"arc-group\")\r\n\t\t\t\t\t.append(\"path\")\r\n\t\t\t\t\t.attr(\"d\", arcGen)\r\n\t\t\t\t\t.attr(\"fill\", d => d.data.color)\r\n\t\t\t\t\t.style(\"opacity\", d => (d.data.isRemainder ? 0.5 : 0.9))\r\n\t\t\t\t\t.style(\"stroke\", \"#fff\")\r\n\t\t\t\t\t.style(\"stroke-width\", 1.5)\r\n\t\t\t\t\t.on(\"mouseover\", function (event, d) {\r\n\t\t\t\t\t\tif (d.data.isRemainder) return;\r\n\t\t\t\t\t\td3.select(this)\r\n\t\t\t\t\t\t\t.transition()\r\n\t\t\t\t\t\t\t.duration(150)\r\n\t\t\t\t\t\t\t.style(\"opacity\", 1)\r\n\t\t\t\t\t\t\t.attr(\"transform\", \"scale(1.03)\");\r\n\t\t\t\t\t\ttooltip\r\n\t\t\t\t\t\t\t.style(\"visibility\", \"visible\")\r\n\t\t\t\t\t\t\t.html(\r\n\t\t\t\t\t\t\t\t`<strong>${d.data.name}</strong>: ${d.data.value.toFixed(1)}${\r\n\t\t\t\t\t\t\t\t\tprops.type === \"percentage\" ? \"%\" : \"\"\r\n\t\t\t\t\t\t\t\t}`\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.on(\"mousemove\", function (event) {\r\n\t\t\t\t\t\tconst [mouseX, mouseY] = d3.pointer(event, pieContainer.value); // Position relative to container\r\n\t\t\t\t\t\ttooltip\r\n\t\t\t\t\t\t\t.style(\"top\", mouseY + 15 + \"px\")\r\n\t\t\t\t\t\t\t.style(\"left\", mouseX + 15 + \"px\");\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.on(\"mouseout\", function (event, d) {\r\n\t\t\t\t\t\tif (d.data.isRemainder) return;\r\n\t\t\t\t\t\td3.select(this)\r\n\t\t\t\t\t\t\t.transition()\r\n\t\t\t\t\t\t\t.duration(150)\r\n\t\t\t\t\t\t\t.style(\"opacity\", 0.9)\r\n\t\t\t\t\t\t\t.attr(\"transform\", \"scale(1)\");\r\n\t\t\t\t\t\ttooltip.style(\"visibility\", \"hidden\");\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.on(\"click\", function (event, d) {\r\n\t\t\t\t\t\tif (d.data.isRemainder) return;\r\n\t\t\t\t\t\temit(\"chartClick\", {\r\n\t\t\t\t\t\t\ttype: \"pie\",\r\n\t\t\t\t\t\t\tindex: d.index,\r\n\t\t\t\t\t\t\tdata: d.data,\r\n\t\t\t\t\t\t\tvalue: d.data.value\r\n\t\t\t\t\t\t}); // d.index from original pieData map\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\tif (isSingleValue && pieData.value.length === 1) {\r\n\t\t\t\t\tsvg\r\n\t\t\t\t\t\t.append(\"text\")\r\n\t\t\t\t\t\t.attr(\"text-anchor\", \"middle\")\r\n\t\t\t\t\t\t.attr(\"dy\", \".3em\")\r\n\t\t\t\t\t\t.text(\r\n\t\t\t\t\t\t\t`${pieData.value[0].value.toFixed(1)}${\r\n\t\t\t\t\t\t\t\tprops.type === \"percentage\" ? \"%\" : \"\"\r\n\t\t\t\t\t\t\t}`\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t.style(\"font-size\", `${Math.max(12, radius * 0.25)}px`)\r\n\t\t\t\t\t\t.style(\"fill\", \"#333\")\r\n\t\t\t\t\t\t.style(\"font-weight\", \"bold\");\r\n\t\t\t\t} else if (!isSingleValue && pieData.value.length > 1) {\r\n\t\t\t\t\t// Legend for multi-value pie chart\r\n\t\t\t\t\tconst legendContainer = d3.select(pieContainer.value).select(\"svg\"); // Attach to SVG, not the 'g'\r\n\t\t\t\t\tconst legendItemSize = 10,\r\n\t\t\t\t\t\tlegendSpacing = 3,\r\n\t\t\t\t\t\tlegendPaddingRight = 5,\r\n\t\t\t\t\t\tlegendPaddingTop = 5;\r\n\t\t\t\t\tlet maxTextW = 0;\r\n\t\t\t\t\tconst tempTextMeasure = d3\r\n\t\t\t\t\t\t.select(\"body\")\r\n\t\t\t\t\t\t.append(\"svg\")\r\n\t\t\t\t\t\t.attr(\"class\", \"temp-text-measure\")\r\n\t\t\t\t\t\t.style(\"visibility\", \"hidden\");\r\n\t\t\t\t\tdataForPieDisplay\r\n\t\t\t\t\t\t.filter(d => !d.isRemainder)\r\n\t\t\t\t\t\t.forEach(d => {\r\n\t\t\t\t\t\t\tmaxTextW = Math.max(\r\n\t\t\t\t\t\t\t\tmaxTextW,\r\n\t\t\t\t\t\t\t\ttempTextMeasure\r\n\t\t\t\t\t\t\t\t\t.append(\"text\")\r\n\t\t\t\t\t\t\t\t\t.text(`${d.name} (${d.value.toFixed(1)}%)`)\r\n\t\t\t\t\t\t\t\t\t.style(\"font-size\", \"10px\")\r\n\t\t\t\t\t\t\t\t\t.node()\r\n\t\t\t\t\t\t\t\t\t.getComputedTextLength()\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\ttempTextMeasure.remove();\r\n\t\t\t\t\tconst legendItemTotalW =\r\n\t\t\t\t\t\tlegendItemSize + legendSpacing + maxTextW + legendPaddingRight;\r\n\r\n\t\t\t\t\tconst legend = legendContainer\r\n\t\t\t\t\t\t.append(\"g\")\r\n\t\t\t\t\t\t.attr(\"class\", \"legend-pie\")\r\n\t\t\t\t\t\t.selectAll(\"g\")\r\n\t\t\t\t\t\t.data(dataForPieDisplay.filter(d => !d.isRemainder))\r\n\t\t\t\t\t\t.join(\"g\")\r\n\t\t\t\t\t\t.attr(\r\n\t\t\t\t\t\t\t\"transform\",\r\n\t\t\t\t\t\t\t(d, i) =>\r\n\t\t\t\t\t\t\t\t`translate(${size - legendItemTotalW}, ${\r\n\t\t\t\t\t\t\t\t\tlegendPaddingTop + i * (legendItemSize + legendSpacing + 2)\r\n\t\t\t\t\t\t\t\t})`\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\tlegend\r\n\t\t\t\t\t\t.append(\"rect\")\r\n\t\t\t\t\t\t.attr(\"width\", legendItemSize)\r\n\t\t\t\t\t\t.attr(\"height\", legendItemSize)\r\n\t\t\t\t\t\t.attr(\"fill\", d => d.color);\r\n\t\t\t\t\tlegend\r\n\t\t\t\t\t\t.append(\"text\")\r\n\t\t\t\t\t\t.attr(\"x\", legendItemSize + legendSpacing)\r\n\t\t\t\t\t\t.attr(\"y\", legendItemSize / 2)\r\n\t\t\t\t\t\t.attr(\"dy\", \"0.32em\")\r\n\t\t\t\t\t\t.text(\r\n\t\t\t\t\t\t\td =>\r\n\t\t\t\t\t\t\t\t`${d.name.substring(0, 15)}${\r\n\t\t\t\t\t\t\t\t\td.name.length > 15 ? \"...\" : \"\"\r\n\t\t\t\t\t\t\t\t} (${d.value.toFixed(1)}%)`\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t.style(\"font-size\", \"10px\")\r\n\t\t\t\t\t\t.style(\"fill\", \"#333\");\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Bar chart data pre-processing\r\n\t\t\tconst simpleBarData = computed(() => {\r\n\t\t\t\tif (\r\n\t\t\t\t\tprops.visualization !== \"bar-chart\" ||\r\n\t\t\t\t\t!hasData.value ||\r\n\t\t\t\t\t!Array.isArray(processedField.value)\r\n\t\t\t\t)\r\n\t\t\t\t\treturn [];\r\n\t\t\t\treturn processedField.value\r\n\t\t\t\t\t.map((item, index) => ({\r\n\t\t\t\t\t\tname: String(item.name || `Bar ${index + 1}`),\r\n\t\t\t\t\t\tvalue: typeof item.value === \"number\" ? item.value : 0,\r\n\t\t\t\t\t\traw: String(item.raw || \"\"),\r\n\t\t\t\t\t\tindex\r\n\t\t\t\t\t}))\r\n\t\t\t\t\t.filter(item => !isYearEntry(item.raw));\r\n\t\t\t});\r\n\r\n\t\t\tconst renderBarChart = () => {\r\n\t\t\t\tif (!barContainer.value) {\r\n\t\t\t\t\t/* console.error(\"Bar container not found\"); */ return;\r\n\t\t\t\t}\r\n\t\t\t\t// console.log(`renderBarChart for ${props.fieldKey}, data:`, JSON.parse(JSON.stringify(simpleBarData.value)));\r\n\t\t\t\td3.select(barContainer.value).selectAll(\"*\").remove();\r\n\t\t\t\tif (!simpleBarData.value || simpleBarData.value.length === 0) {\r\n\t\t\t\t\td3.select(barContainer.value).html(`<div class=\"no-data\">-</div>`);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst container = d3.select(barContainer.value);\r\n\t\t\t\tconst width = barContainer.value.clientWidth;\r\n\t\t\t\tconst height = barContainer.value.clientHeight;\r\n\t\t\t\tconst margin = {\r\n\t\t\t\t\ttop: 10,\r\n\t\t\t\t\tright: 10,\r\n\t\t\t\t\tbottom:\r\n\t\t\t\t\t\t25 + (simpleBarData.value.some(d => d.name.length > 7) ? 10 : 0),\r\n\t\t\t\t\tleft: 35\r\n\t\t\t\t}; // Adjust bottom for long labels\r\n\t\t\t\tconst chartWidth = width - margin.left - margin.right;\r\n\t\t\t\tconst chartHeight = height - margin.top - margin.bottom;\r\n\r\n\t\t\t\tif (chartWidth <= 0 || chartHeight <= 0) {\r\n\t\t\t\t\t/* console.warn(\"Bar chart area too small\"); */ d3.select(\r\n\t\t\t\t\t\tbarContainer.value\r\n\t\t\t\t\t).html(`<div class=\"no-data\">- (Area too small)</div>`);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst svg = container\r\n\t\t\t\t\t.append(\"svg\")\r\n\t\t\t\t\t.attr(\"width\", width)\r\n\t\t\t\t\t.attr(\"height\", height)\r\n\t\t\t\t\t.append(\"g\")\r\n\t\t\t\t\t.attr(\"transform\", `translate(${margin.left},${margin.top})`);\r\n\r\n\t\t\t\tconst x = d3\r\n\t\t\t\t\t.scaleBand()\r\n\t\t\t\t\t.domain(simpleBarData.value.map(d => d.name))\r\n\t\t\t\t\t.range([0, chartWidth])\r\n\t\t\t\t\t.padding(0.2);\r\n\r\n\t\t\t\tconst yValues = simpleBarData.value.map(d => d.value);\r\n\t\t\t\tconst yMin = d3.min(yValues);\r\n\t\t\t\tconst yMax = d3.max(yValues);\r\n\t\t\t\tconst y = d3\r\n\t\t\t\t\t.scaleLinear()\r\n\t\t\t\t\t.domain([\r\n\t\t\t\t\t\tyMin < 0 ? yMin * 1.1 : 0,\r\n\t\t\t\t\t\tyMax > 0 ? yMax * 1.1 : props.unifiedMax || 10\r\n\t\t\t\t\t]) // Handle all zero/negative/positive cases\r\n\t\t\t\t\t.nice()\r\n\t\t\t\t\t.range([chartHeight, 0]);\r\n\r\n\t\t\t\tsvg.append(\"g\").call(\r\n\t\t\t\t\td3\r\n\t\t\t\t\t\t.axisLeft(y)\r\n\t\t\t\t\t\t.ticks(5)\r\n\t\t\t\t\t\t.tickFormat(d => formatNumber(d))\r\n\t\t\t\t);\r\n\t\t\t\tsvg\r\n\t\t\t\t\t.append(\"g\")\r\n\t\t\t\t\t.attr(\"transform\", `translate(0,${chartHeight})`)\r\n\t\t\t\t\t.call(d3.axisBottom(x))\r\n\t\t\t\t\t.selectAll(\"text\")\r\n\t\t\t\t\t.style(\"text-anchor\", \"end\")\r\n\t\t\t\t\t.attr(\"dx\", \"-.8em\")\r\n\t\t\t\t\t.attr(\"dy\", \".15em\")\r\n\t\t\t\t\t.attr(\"transform\", \"rotate(-30)\");\r\n\r\n\t\t\t\tsvg\r\n\t\t\t\t\t.selectAll(\".bar\")\r\n\t\t\t\t\t.data(simpleBarData.value)\r\n\t\t\t\t\t.enter()\r\n\t\t\t\t\t.append(\"rect\")\r\n\t\t\t\t\t.attr(\"class\", \"bar\")\r\n\t\t\t\t\t.attr(\"x\", d => x(d.name))\r\n\t\t\t\t\t.attr(\"y\", d => (d.value >= 0 ? y(d.value) : y(0))) // Handle negative values for y\r\n\t\t\t\t\t.attr(\"width\", x.bandwidth())\r\n\t\t\t\t\t.attr(\"height\", d => Math.abs(y(d.value) - y(0))) // Absolute height\r\n\t\t\t\t\t.attr(\"fill\", (d, i) => colors[i % colors.length])\r\n\t\t\t\t\t.style(\"opacity\", 0.8)\r\n\t\t\t\t\t.append(\"title\")\r\n\t\t\t\t\t.text(d => `${d.name}: ${formatNumber(d.value)}`);\r\n\r\n\t\t\t\t// Optional: Value labels on top of bars\r\n\t\t\t\tsvg\r\n\t\t\t\t\t.selectAll(\".bar-value-label\")\r\n\t\t\t\t\t.data(simpleBarData.value)\r\n\t\t\t\t\t.enter()\r\n\t\t\t\t\t.append(\"text\")\r\n\t\t\t\t\t.attr(\"class\", \"bar-value-label\")\r\n\t\t\t\t\t.attr(\"x\", d => x(d.name) + x.bandwidth() / 2)\r\n\t\t\t\t\t.attr(\"y\", d => y(d.value) - 3)\r\n\t\t\t\t\t.attr(\"text-anchor\", \"middle\")\r\n\t\t\t\t\t.style(\"font-size\", \"9px\")\r\n\t\t\t\t\t.style(\"fill\", \"#444\")\r\n\t\t\t\t\t.text(d => formatNumber(d.value));\r\n\t\t\t};\r\n\r\n\t\t\t// Line chart data pre-processing\r\n\t\t\tconst lineData = computed(() => {\r\n\t\t\t\tif (\r\n\t\t\t\t\tprops.visualization !== \"line-chart\" ||\r\n\t\t\t\t\t!hasData.value ||\r\n\t\t\t\t\t!Array.isArray(processedField.value)\r\n\t\t\t\t)\r\n\t\t\t\t\treturn [];\r\n\t\t\t\treturn processedField.value\r\n\t\t\t\t\t.map((item, index) => ({\r\n\t\t\t\t\t\tname: String(item.name || `Point ${index + 1}`), // Name might be year or category\r\n\t\t\t\t\t\tvalue: typeof item.value === \"number\" ? item.value : 0,\r\n\t\t\t\t\t\traw: String(item.raw || \"\"),\r\n\t\t\t\t\t\toriginalIndex: index // Keep original index if needed for x-axis from name\r\n\t\t\t\t\t}))\r\n\t\t\t\t\t.filter(item => !isYearEntry(item.raw));\r\n\t\t\t});\r\n\r\n\t\t\tconst renderLineChart = () => {\r\n\t\t\t\tif (!lineContainer.value) {\r\n\t\t\t\t\t/* console.error(\"Line container not found\"); */ return;\r\n\t\t\t\t}\r\n\t\t\t\t// console.log(`renderLineChart for ${props.fieldKey}, data:`, JSON.parse(JSON.stringify(lineData.value)));\r\n\t\t\t\td3.select(lineContainer.value).selectAll(\"*\").remove();\r\n\t\t\t\tif (!lineData.value || lineData.value.length < 1) {\r\n\t\t\t\t\t// Line chart needs at least 1 point, ideally 2+\r\n\t\t\t\t\td3.select(lineContainer.value).html(`<div class=\"no-data\">-</div>`);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconst container = d3.select(lineContainer.value);\r\n\t\t\t\tconst width = lineContainer.value.clientWidth;\r\n\t\t\t\tconst height = lineContainer.value.clientHeight;\r\n\t\t\t\tconst margin = {\r\n\t\t\t\t\ttop: 10,\r\n\t\t\t\t\tright: 20,\r\n\t\t\t\t\tbottom: 25 + (lineData.value.some(d => d.name.length > 7) ? 10 : 0),\r\n\t\t\t\t\tleft: 40\r\n\t\t\t\t};\r\n\t\t\t\tconst chartWidth = width - margin.left - margin.right;\r\n\t\t\t\tconst chartHeight = height - margin.top - margin.bottom;\r\n\r\n\t\t\t\tif (chartWidth <= 0 || chartHeight <= 0) {\r\n\t\t\t\t\t/* console.warn(\"Line chart area too small\"); */ d3.select(\r\n\t\t\t\t\t\tlineContainer.value\r\n\t\t\t\t\t).html(`<div class=\"no-data\">- (Area too small)</div>`);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst svg = container\r\n\t\t\t\t\t.append(\"svg\")\r\n\t\t\t\t\t.attr(\"width\", width)\r\n\t\t\t\t\t.attr(\"height\", height)\r\n\t\t\t\t\t.append(\"g\")\r\n\t\t\t\t\t.attr(\"transform\", `translate(${margin.left},${margin.top})`);\r\n\r\n\t\t\t\t// X scale: can be index-based or based on 'name' if names are ordered categories/years\r\n\t\t\t\tconst x = d3\r\n\t\t\t\t\t.scalePoint() // Use scalePoint if names are categories\r\n\t\t\t\t\t.domain(lineData.value.map(d => d.name))\r\n\t\t\t\t\t.range([0, chartWidth])\r\n\t\t\t\t\t.padding(0.5);\r\n\r\n\t\t\t\tconst yValues = lineData.value.map(d => d.value);\r\n\t\t\t\tconst y = d3\r\n\t\t\t\t\t.scaleLinear()\r\n\t\t\t\t\t.domain(d3.extent(yValues)) // Use extent for min/max\r\n\t\t\t\t\t.nice()\r\n\t\t\t\t\t.range([chartHeight, 0]);\r\n\r\n\t\t\t\tsvg.append(\"g\").call(\r\n\t\t\t\t\td3\r\n\t\t\t\t\t\t.axisLeft(y)\r\n\t\t\t\t\t\t.ticks(5)\r\n\t\t\t\t\t\t.tickFormat(d => formatNumber(d))\r\n\t\t\t\t);\r\n\t\t\t\tsvg\r\n\t\t\t\t\t.append(\"g\")\r\n\t\t\t\t\t.attr(\"transform\", `translate(0,${chartHeight})`)\r\n\t\t\t\t\t.call(d3.axisBottom(x))\r\n\t\t\t\t\t.selectAll(\"text\")\r\n\t\t\t\t\t.style(\"text-anchor\", \"end\")\r\n\t\t\t\t\t.attr(\"dx\", \"-.8em\")\r\n\t\t\t\t\t.attr(\"dy\", \".15em\")\r\n\t\t\t\t\t.attr(\"transform\", \"rotate(-30)\");\r\n\r\n\t\t\t\tconst lineGen = d3\r\n\t\t\t\t\t.line()\r\n\t\t\t\t\t.x(d => x(d.name))\r\n\t\t\t\t\t.y(d => y(d.value))\r\n\t\t\t\t\t.curve(d3.curveMonotoneX); // Smoother line\r\n\r\n\t\t\t\tsvg\r\n\t\t\t\t\t.append(\"path\")\r\n\t\t\t\t\t.datum(lineData.value)\r\n\t\t\t\t\t.attr(\"fill\", \"none\")\r\n\t\t\t\t\t.attr(\"stroke\", colors[0])\r\n\t\t\t\t\t.attr(\"stroke-width\", 2)\r\n\t\t\t\t\t.attr(\"d\", lineGen);\r\n\r\n\t\t\t\tsvg\r\n\t\t\t\t\t.selectAll(\".dot\")\r\n\t\t\t\t\t.data(lineData.value)\r\n\t\t\t\t\t.enter()\r\n\t\t\t\t\t.append(\"circle\")\r\n\t\t\t\t\t.attr(\"class\", \"dot\")\r\n\t\t\t\t\t.attr(\"cx\", d => x(d.name))\r\n\t\t\t\t\t.attr(\"cy\", d => y(d.value))\r\n\t\t\t\t\t.attr(\"r\", 3)\r\n\t\t\t\t\t.attr(\"fill\", colors[0])\r\n\t\t\t\t\t.append(\"title\")\r\n\t\t\t\t\t.text(d => `${d.name}: ${formatNumber(d.value)}`);\r\n\t\t\t};\r\n\r\n\t\t\tconst renderStackedChart = () => {\r\n\t\t\t\t// 100% 纵向堆叠条形图\r\n\t\t\t\tif (!stackedContainer.value) {\r\n\t\t\t\t\t/* console.error(\"renderStackedChart: stackedContainer ref is not available.\"); */ return;\r\n\t\t\t\t}\r\n\t\t\t\tconst rawDataObject =\r\n\t\t\t\t\tprocessedField.value && processedField.value.length === 1\r\n\t\t\t\t\t\t? processedField.value[0]\r\n\t\t\t\t\t\t: {};\r\n\t\t\t\tconst seriesNames = Object.keys(rawDataObject).filter(\r\n\t\t\t\t\tkey =>\r\n\t\t\t\t\t\ttypeof rawDataObject[key] === \"number\" && rawDataObject[key] > 0\r\n\t\t\t\t); // Only use keys with positive numeric values\r\n\r\n\t\t\t\t// console.log(`renderStackedChart for ${props.fieldKey}. Series Names:`, seriesNames, \"Raw Data Obj:\", JSON.parse(JSON.stringify(rawDataObject)));\r\n\r\n\t\t\t\td3.select(stackedContainer.value).selectAll(\"*\").remove();\r\n\t\t\t\tif (seriesNames.length === 0) {\r\n\t\t\t\t\t// console.warn(\"renderStackedChart: No series data to render. Clearing container.\");\r\n\t\t\t\t\td3.select(stackedContainer.value).html(\r\n\t\t\t\t\t\t`<div class=\"no-data\" style=\"text-align:center;\">-</div>`\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst container = d3.select(stackedContainer.value);\r\n\t\t\t\tlet width = stackedContainer.value.clientWidth;\r\n\t\t\t\tlet height = stackedContainer.value.clientHeight;\r\n\t\t\t\tif (width === 0 || height === 0) {\r\n\t\t\t\t\t/* width = 300; height = 150; */ /* console.warn(\"Stacked container zero dimensions\"); */ return;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst margin = { top: 5, right: 130, bottom: 5, left: 5 }; // Minimal margins, legend on right\r\n\t\t\t\tconst chartWidth = width - margin.left - margin.right;\r\n\t\t\t\tconst chartHeight = height - margin.top - margin.bottom;\r\n\r\n\t\t\t\tif (chartWidth <= 0 || chartHeight <= 0) {\r\n\t\t\t\t\t// console.warn(\"renderStackedChart: Chart dimensions are invalid after applying margins.\");\r\n\t\t\t\t\td3.select(stackedContainer.value).html(\r\n\t\t\t\t\t\t`<div class=\"no-data\" style=\"text-align:center;\">- (Area too small)</div>`\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst svg = container\r\n\t\t\t\t\t.append(\"svg\")\r\n\t\t\t\t\t.attr(\"width\", width)\r\n\t\t\t\t\t.attr(\"height\", height)\r\n\t\t\t\t\t.append(\"g\")\r\n\t\t\t\t\t.attr(\"transform\", `translate(${margin.left},${margin.top})`);\r\n\r\n\t\t\t\tconst stack = d3\r\n\t\t\t\t\t.stack()\r\n\t\t\t\t\t.keys(seriesNames)\r\n\t\t\t\t\t.order(d3.stackOrderAppearance)\r\n\t\t\t\t\t.offset(d3.stackOffsetNone);\r\n\t\t\t\tconst stackedSeriesInput = [rawDataObject];\r\n\t\t\t\tlet series = stack(stackedSeriesInput);\r\n\r\n\t\t\t\tconst total = d3.sum(seriesNames, key => rawDataObject[key]);\r\n\t\t\t\tseries.forEach(s => {\r\n\t\t\t\t\ts.forEach(d => {\r\n\t\t\t\t\t\td[0] = total > 0 ? (d[0] / total) * 100 : 0;\r\n\t\t\t\t\t\td[1] = total > 0 ? (d[1] / total) * 100 : 0;\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t\t// console.log(\"Normalized D3 Stacked Series for 100%:\", JSON.parse(JSON.stringify(series)));\r\n\r\n\t\t\t\tconst y = d3.scaleLinear().domain([0, 100]).range([chartHeight, 0]);\r\n\t\t\t\tconst barCategory = [\"Category\"]; // Single category for the bar\r\n\t\t\t\tconst x = d3\r\n\t\t\t\t\t.scaleBand()\r\n\t\t\t\t\t.domain(barCategory)\r\n\t\t\t\t\t.range([0, chartWidth])\r\n\t\t\t\t\t.paddingInner(0.7)\r\n\t\t\t\t\t.paddingOuter(0.35); // Adjust padding for single bar width\r\n\r\n\t\t\t\tsvg\r\n\t\t\t\t\t.append(\"g\")\r\n\t\t\t\t\t.selectAll(\"g\")\r\n\t\t\t\t\t.data(series)\r\n\t\t\t\t\t.join(\"g\")\r\n\t\t\t\t\t.attr(\"fill\", (d, i) => colors[i % colors.length])\r\n\t\t\t\t\t.selectAll(\"rect\")\r\n\t\t\t\t\t.data(d => d)\r\n\t\t\t\t\t.join(\"rect\")\r\n\t\t\t\t\t.attr(\"x\", x(barCategory[0]))\r\n\t\t\t\t\t.attr(\"y\", d => y(d[1]))\r\n\t\t\t\t\t.attr(\"height\", d => Math.max(0, y(d[0]) - y(d[1]))) // Ensure non-negative height\r\n\t\t\t\t\t.attr(\"width\", x.bandwidth())\r\n\t\t\t\t\t.append(\"title\")\r\n\t\t\t\t\t.text((d_rect, i_rect, nodes_rect) => {\r\n\t\t\t\t\t\tconst seriesData = d3.select(nodes_rect[i_rect].parentNode).datum();\r\n\t\t\t\t\t\tconst originalValue = rawDataObject[seriesData.key];\r\n\t\t\t\t\t\tconst percentageOfBar =\r\n\t\t\t\t\t\t\t((y(d_rect[0]) - y(d_rect[1])) / chartHeight) * 100;\r\n\t\t\t\t\t\treturn `${seriesData.key}: ${originalValue.toFixed(\r\n\t\t\t\t\t\t\t1\r\n\t\t\t\t\t\t)}% (${percentageOfBar.toFixed(1)}% of bar)`;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\tconst legend = svg\r\n\t\t\t\t\t.append(\"g\")\r\n\t\t\t\t\t.attr(\"class\", \"legend-stacked\")\r\n\t\t\t\t\t.attr(\"font-family\", \"sans-serif\")\r\n\t\t\t\t\t.attr(\"font-size\", 10)\r\n\t\t\t\t\t.attr(\"text-anchor\", \"start\")\r\n\t\t\t\t\t.selectAll(\"g\")\r\n\t\t\t\t\t.data(series)\r\n\t\t\t\t\t.join(\"g\")\r\n\t\t\t\t\t.attr(\r\n\t\t\t\t\t\t\"transform\",\r\n\t\t\t\t\t\t(d, i) => `translate(${chartWidth + 10},${i * 18 + margin.top})`\r\n\t\t\t\t\t); // Adjusted spacing\r\n\r\n\t\t\t\tlegend\r\n\t\t\t\t\t.append(\"rect\")\r\n\t\t\t\t\t.attr(\"x\", 0)\r\n\t\t\t\t\t.attr(\"width\", 12)\r\n\t\t\t\t\t.attr(\"height\", 12)\r\n\t\t\t\t\t.attr(\"fill\", (d, i) => colors[i % colors.length]);\r\n\t\t\t\tlegend\r\n\t\t\t\t\t.append(\"text\")\r\n\t\t\t\t\t.attr(\"x\", 16)\r\n\t\t\t\t\t.attr(\"y\", 6)\r\n\t\t\t\t\t.attr(\"dy\", \"0.32em\")\r\n\t\t\t\t\t.text(d => {\r\n\t\t\t\t\t\tconst name = d.key;\r\n\t\t\t\t\t\tconst originalValue = rawDataObject[d.key];\r\n\t\t\t\t\t\treturn `${\r\n\t\t\t\t\t\t\tname.length > 13 ? name.substring(0, 11) + \"...\" : name\r\n\t\t\t\t\t\t} (${originalValue.toFixed(1)}%)`;\r\n\t\t\t\t\t});\r\n\t\t\t\t// console.log(\"renderStackedChart FINISHED drawing (100% stacked bar).\");\r\n\t\t\t};\r\n\r\n\t\t\tconst formatSimpleText = value => {\r\n\t\t\t\tif (value === null || value === undefined) return \"-\";\r\n\t\t\t\tlet textToShow;\r\n\t\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\t\tif (value.length === 0) return \"-\";\r\n\t\t\t\t\ttextToShow = value\r\n\t\t\t\t\t\t.map(item => {\r\n\t\t\t\t\t\t\tif (typeof item === \"object\" && item !== null) {\r\n\t\t\t\t\t\t\t\tlet text = String(item.raw || item.value || item.name || \"\");\r\n\t\t\t\t\t\t\t\t// Avoid appending unit/year if already in raw/value for text-only\r\n\t\t\t\t\t\t\t\t// if (item.unit && !text.includes(item.unit)) text += ` ${item.unit}`;\r\n\t\t\t\t\t\t\t\t// if (item.year && !text.includes(String(item.year))) text += ` (${item.year})`;\r\n\t\t\t\t\t\t\t\treturn text;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn String(item);\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.join(\"; \");\r\n\t\t\t\t} else if (typeof value === \"object\" && value !== null) {\r\n\t\t\t\t\ttextToShow = String(value.raw || value.value || value.name || \"-\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttextToShow = String(value);\r\n\t\t\t\t}\r\n\t\t\t\treturn textToShow.length > 70\r\n\t\t\t\t\t? textToShow.substring(0, 67) + \"...\"\r\n\t\t\t\t\t: textToShow;\r\n\t\t\t};\r\n\r\n\t\t\tconst handleTextClick = () => {\r\n\t\t\t\temit(\"chartClick\", {\r\n\t\t\t\t\ttype: \"text\",\r\n\t\t\t\t\tdata: processedField.value,\r\n\t\t\t\t\tvalue: processedField.value\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t\tconst handleTextHover = () => {\r\n\t\t\t\tisTextHovered.value = true;\r\n\t\t\t};\r\n\t\t\tconst resetHover = () => {\r\n\t\t\t\tisTextHovered.value = false;\r\n\t\t\t\thoveredIndex.value = null;\r\n\t\t\t\tactiveIndex.value = null;\r\n\t\t\t};\r\n\r\n\t\t\treturn {\r\n\t\t\t\tpieContainer,\r\n\t\t\t\tbarContainer,\r\n\t\t\t\tlineContainer,\r\n\t\t\t\tstackedContainer,\r\n\t\t\t\tformatSimpleText,\r\n\t\t\t\thandleTextClick,\r\n\t\t\t\thandleTextHover,\r\n\t\t\t\tresetHover,\r\n\t\t\t\tisTextHovered,\r\n\t\t\t\thasData,\r\n\t\t\t\tisValidPieData // These are used in the template v-if conditions\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n</script>\r\n\r\n<style scoped>\r\n\t.simple-chart {\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t\tdisplay: flex;\r\n\t\talign-items: center;\r\n\t\tjustify-content: center;\r\n\t\tposition: relative;\r\n\t\tfont-family: Arial, sans-serif;\r\n\t}\r\n\r\n\t.simple-text {\r\n\t\ttext-align: center;\r\n\t\tfont-size: 13px; /* Slightly smaller for more text */\r\n\t\tline-height: 1.3;\r\n\t\tword-break: break-word;\r\n\t\tpadding: 6px; /* Reduced padding */\r\n\t\tcursor: pointer;\r\n\t\ttransition: all 0.2s ease;\r\n\t\tborder-radius: 4px;\r\n\t\tbackground-color: #f8f9fa;\r\n\t\tmax-width: 100%;\r\n\t\tmax-height: 100%; /* Ensure text doesn't overflow cell */\r\n\t\toverflow-y: auto; /* Allow scroll if text too long */\r\n\t}\r\n\r\n\t.simple-text:hover {\r\n\t\tbackground-color: #e9ecef;\r\n\t}\r\n\r\n\t.text-tooltip {\r\n\t\tposition: absolute;\r\n\t\ttop: -22px; /* Adjust if needed */\r\n\t\tleft: 50%;\r\n\t\ttransform: translateX(-50%);\r\n\t\tbackground-color: rgba(0, 0, 0, 0.8);\r\n\t\tcolor: white;\r\n\t\tpadding: 3px 7px;\r\n\t\tborder-radius: 3px;\r\n\t\tfont-size: 11px;\r\n\t\tpointer-events: none;\r\n\t\twhite-space: nowrap;\r\n\t\tz-index: 10;\r\n\t}\r\n\r\n\t.d3-chart-container {\r\n\t\twidth: 100%;\r\n\t\theight: 100%;\r\n\t\tdisplay: flex;\r\n\t\talign-items: center;\r\n\t\tjustify-content: center;\r\n\t\tposition: relative;\r\n\t\toverflow: visible; /* Important for legends outside main chart area */\r\n\t}\r\n\r\n\t:deep(.d3-tooltip) {\r\n\t\tposition: absolute;\r\n\t\tz-index: 20; /* Higher z-index for tooltips */\r\n\t\twhite-space: nowrap;\r\n\t\tpointer-events: none;\r\n\t\tbox-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);\r\n\t\tbackground: rgba(40, 40, 40, 0.9); /* Darker tooltip */\r\n\t\tcolor: white;\r\n\t\tpadding: 5px 10px;\r\n\t\tborder-radius: 4px;\r\n\t\tfont-size: 11px;\r\n\t\tline-height: 1.4;\r\n\t}\r\n\t:deep(.d3-tooltip strong) {\r\n\t\tfont-weight: bold;\r\n\t\tdisplay: block;\r\n\t\tmargin-bottom: 2px;\r\n\t}\r\n\r\n\t.no-data {\r\n\t\tcolor: #888; /* Slightly darker */\r\n\t\tfont-style: italic;\r\n\t\tfont-size: 12px; /* Smaller no-data text */\r\n\t\tpadding: 10px;\r\n\t\ttext-align: center;\r\n\t\twidth: 100%;\r\n\t\talign-self: center; /* Vertically center */\r\n\t}\r\n\r\n\t/* Styles for D3 generated elements */\r\n\t:deep(.tick text) {\r\n\t\tfont-size: 9px;\r\n\t\tfill: #444; /* Darker tick text */\r\n\t}\r\n\t:deep(.tick line) {\r\n\t\tstroke: #d0d0d0; /* Lighter tick lines */\r\n\t}\r\n\t:deep(path.domain) {\r\n\t\t/* Axis line */\r\n\t\tstroke: #888;\r\n\t}\r\n\t:deep(.legend-pie text),\r\n\t:deep(.legend-stacked text) {\r\n\t\t/* Common legend text style */\r\n\t\tfont-size: 9.5px; /* Slightly larger legend text */\r\n\t\tfill: #333;\r\n\t\tuser-select: none;\r\n\t}\r\n\r\n\t:deep(.bar:hover),\r\n\t:deep(.stack-bar rect:hover) {\r\n\t\t/* target the rect inside stack-bar group */\r\n\t\topacity: 1 !important;\r\n\t\t/* stroke: #333; */ /* Optional: add hover stroke */\r\n\t\t/* stroke-width: 1px; */\r\n\t}\r\n\t:deep(.bar-value-label),\r\n\t:deep(.stack-value-label),\r\n\t:deep(.line-label) {\r\n\t\tpointer-events: none;\r\n\t\tfont-size: 9px;\r\n\t\tfill: #333;\r\n\t}\r\n\t:deep(.dot:hover) {\r\n\t\tr: 4.5px !important; /* Enlarge dot on hover */\r\n\t\tstroke: #000;\r\n\t\tstroke-width: 1px;\r\n\t}\r\n\r\n\t@media (max-width: 768px) {\r\n\t\t.simple-text {\r\n\t\t\tfont-size: 11px;\r\n\t\t\tpadding: 4px;\r\n\t\t}\r\n\t\t:deep(.tick text) {\r\n\t\t\tfont-size: 7.5px;\r\n\t\t}\r\n\t\t:deep(.legend-pie text),\r\n\t\t:deep(.legend-stacked text) {\r\n\t\t\tfont-size: 7.5px;\r\n\t\t}\r\n\t\t.text-tooltip {\r\n\t\t\tfont-size: 10px;\r\n\t\t\tpadding: 2px 5px;\r\n\t\t}\r\n\t}\r\n</style>\r\n"],"mappings":";;;EACMA,KAAK,EAAC;AAAc;;EAD1BC,GAAA;EAW6BD,KAAK,EAAC;;;EAXnCC,GAAA;EAkBID,KAAK,EAAC,oBAAoB;EAC1BE,GAAG,EAAC;;;EAnBRD,GAAA;EAoBeD,KAAK,EAAC;;;EApBrBC,GAAA;EAyBuBD,KAAK,EAAC,oBAAoB;EAACE,GAAG,EAAC;;;EAzBtDD,GAAA;EA0BeD,KAAK,EAAC;;;EA1BrBC,GAAA;EA+BuBD,KAAK,EAAC,oBAAoB;EAACE,GAAG,EAAC;;;EA/BtDD,GAAA;EAgCeD,KAAK,EAAC;;;EAhCrBC,GAAA;EAuCID,KAAK,EAAC,oBAAoB;EAC1BE,GAAG,EAAC;;;EAxCRD,GAAA;EAyCeD,KAAK,EAAC;;;EAIbA,KAAK,EAAC;AAAa;;uBA5C1BG,mBAAA,CA8CM,OA9CNC,UA8CM,GA7CLC,mBAAA,UAAa,EACGC,MAAA,CAAAC,aAAa,oB,cAA7BJ,mBAAA,CASWK,SAAA;IAZbP,GAAA;EAAA,IAIGQ,mBAAA,CAMM;IALLT,KAAK,EAAC,aAAa;IAClBU,OAAK,EAAAC,MAAA,QAAAA,MAAA;MAAA,OAAEC,MAAA,CAAAC,eAAA,IAAAD,MAAA,CAAAC,eAAA,IAAAC,SAAA,CAAe;IAAA;IACtBC,YAAU,EAAAJ,MAAA,QAAAA,MAAA;MAAA,OAAEC,MAAA,CAAAI,eAAA,IAAAJ,MAAA,CAAAI,eAAA,IAAAF,SAAA,CAAe;IAAA;IAC3BG,YAAU,EAAAN,MAAA,QAAAA,MAAA;MAAA,OAAEC,MAAA,CAAAM,UAAA,IAAAN,MAAA,CAAAM,UAAA,IAAAJ,SAAA,CAAU;IAAA;sBACpBF,MAAA,CAAAO,gBAAgB,CAACC,IAAA,CAAAC,cAAc,oCAExBT,MAAA,CAAAU,aAAa,I,cAAxBnB,mBAAA,CAA2D,OAA3DoB,UAA2D,EAAZ,QAAM,KAXxDlB,mBAAA,e,+BAeuBC,MAAA,CAAAC,aAAa,oB,cAAlCJ,mBAAA,CAMWK,SAAA;IArBbP,GAAA;EAAA,IAcEI,mBAAA,eAAkB,EAGVO,MAAA,CAAAY,OAAO,IAAIZ,MAAA,CAAAa,cAAc,I,cADhCtB,mBAAA,CAG0B,OAH1BuB,UAG0B,kC,cAC1BvB,mBAAA,CAAmC,OAAnCwB,UAAmC,EAAP,GAAC,G,+BAITrB,MAAA,CAAAC,aAAa,oB,cAAlCJ,mBAAA,CAGWK,SAAA;IA3BbP,GAAA;EAAA,IAuBEI,mBAAA,gBAAmB,EAEPO,MAAA,CAAAY,OAAO,I,cAAlBrB,mBAAA,CAAwE,OAAxEyB,UAAwE,kC,cACxEzB,mBAAA,CAAmC,OAAnC0B,UAAmC,EAAP,GAAC,G,+BAITvB,MAAA,CAAAC,aAAa,qB,cAAlCJ,mBAAA,CAGWK,SAAA;IAjCbP,GAAA;EAAA,IA6BEI,mBAAA,gBAAmB,EAEPO,MAAA,CAAAY,OAAO,I,cAAlBrB,mBAAA,CAAyE,OAAzE2B,UAAyE,kC,cACzE3B,mBAAA,CAAmC,OAAnC4B,UAAmC,EAAP,GAAC,G,+BAITzB,MAAA,CAAAC,aAAa,wB,cAAlCJ,mBAAA,CAMWK,SAAA;IA1CbP,GAAA;EAAA,IAmCEI,mBAAA,oBAAuB,EAGfO,MAAA,CAAAY,OAAO,I,cADdrB,mBAAA,CAG8B,OAH9B6B,UAG8B,kC,cAC9B7B,mBAAA,CAAmC,OAAnC8B,WAAmC,EAAP,GAAC,G,8CAG9B9B,mBAAA,CAEWK,SAAA;IA9CbP,GAAA;EAAA,IA2CEI,mBAAA,2BAA8B,EAE7BI,mBAAA,CAA0D,OAA1DyB,WAA0D,EAAjC,UAAQ,GAAAC,gBAAA,CAAG7B,MAAA,CAAAC,aAAa,iB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}